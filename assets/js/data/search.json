[ { "title": "pt转onnx代码", "url": "/posts/pt2onnx/", "categories": "RM", "tags": "", "date": "2025-04-28 13:42:00 +0800", "snippet": "转换 目前手头上有一些模型，我经常不知道他们的输入尺寸，但是我知道他们具体的输出格式, [batch_size, dynamic_input], batch_size 通常是 1, 所以代码如下:import torchimport os# ==== 配置部分 ====pt_path = &#39;C:/Users/20416/Desktop/unitree_rl_gym/motion.pt&#39; # 你的pt路径onnx_path = &#39;C:/Users/20416/Desktop/unitree_rl_gym/motion.onnx&#39; # 输出onnx路径min_dim = 1max_dim = 512opset = 11 # 可以改成13或更高（按需）# ==== 加载 TorchScript 模型 ====print(f&quot;🔵 正在加载TorchScript模型：{pt_path}&quot;)model = torch.jit.load(pt_path)model.eval()# ==== 自动探测输入尺寸 ====print(f&quot;🛠️ 开始探测输入尺寸...&quot;)input_dim = Nonefor dim in range(min_dim, max_dim + 1): try: dummy_input = torch.randn(1, dim) with torch.no_grad(): output = model(dummy_input) print(f&quot;✅ 可能的输入尺寸：{dummy_input.shape}，输出尺寸：{output.shape}&quot;) input_dim = dim break # 找到就停，不用继续了 except Exception as e: continueif input_dim is None: raise RuntimeError(&quot;❌ 没能找到合适的输入尺寸，请扩大搜索范围。&quot;)# ==== 导出到 ONNX ====print(f&quot;🚀 开始导出 ONNX，使用输入尺寸：{input_dim}&quot;)dummy_input = torch.randn(1, input_dim)torch.onnx.export( model, dummy_input, onnx_path, opset_version=opset, input_names=[&quot;input&quot;], output_names=[&quot;output&quot;], dynamic_axes={&quot;input&quot;: {0: &quot;batch_size&quot;}, &quot;output&quot;: {0: &quot;batch_size&quot;}})print(f&quot;🎯 导出成功！ONNX文件保存在：{onnx_path}&quot;)" }, { "title": "性能优化", "url": "/posts/prefetch/", "categories": "RM", "tags": "", "date": "2023-12-31 20:40:00 +0800", "snippet": "性能优化cpu-bound 与 内存-bound 通常来说，并行加速只能加速计算部分，不能加速内存读写部分，因此并行计算经常遇到内存瓶颈。 因为一次浮点加法的计算量和访存的超高延迟相比实在太少了。 经验公式: 1次浮点读写 ≈ 8次浮点加法 如果矢量化成功（SSE）：1次浮点读写 ≈ 32次浮点加法 如果CPU有4核且矢量化成功：1次浮点读写 ≈ 128次浮点加法所以就要足够的计算量来隐藏操作的延迟。 超线程技术: 不一定是两个线程在两个核上同时运行，而是有可能两个线程同时运行在一个核上，由硬件自动来调度。这个主要是针对如果内存卡住，cpu会自动切换到另一个核上。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;array&amp;gt; #include &amp;lt;benchmark/benchmark.h&amp;gt; #include &amp;lt;x86intrin.h&amp;gt; #include &amp;lt;omp.h&amp;gt; constexpr size_t n = 1&amp;lt;&amp;lt;26; std::vector&amp;lt;float&amp;gt; a(n); // 256MB void BM_fill(benchmark::State &amp;amp;bm) { for (auto _: bm) { for (size_t i = 0; i &amp;lt; n; i++) { a[i] = 1; } } } BENCHMARK(BM_fill); void BM_parallel_fill(benchmark::State &amp;amp;bm) { for (auto _: bm) { #pragma omp parallel for for (size_t i = 0; i &amp;lt; n; i++) { a[i] = 1; } } } BENCHMARK(BM_parallel_fill); void BM_sine(benchmark::State &amp;amp;bm) { for (auto _: bm) { for (size_t i = 0; i &amp;lt; n; i++) { a[i] = std::sin(i); } } } BENCHMARK(BM_sine); void BM_parallel_sine(benchmark::State &amp;amp;bm) { for (auto _: bm) { #pragma omp parallel for for (size_t i = 0; i &amp;lt; n; i++) { a[i] = std::sin(i); } } } BENCHMARK(BM_parallel_sine); BENCHMARK_MAIN(); 这是运行结果: 我们发现，a[i]=1和a[i]=a[i]+1时间差不多，说明访存时间远大于加时间，当计算复杂度高到一定程度后，并行的优势才体现出来。CPU中的高速缓存 这是CPU三个缓存的分级结构图, L1,L2缓存是只给自己核心用的，而L3比较大，可以给多个核心使用。 数据小到装的进二级缓存，则最大带宽就取决于二级缓存的带宽。稍微大一点则只能装到三级缓存，就取决于三级缓存的带宽。三级缓存也装不下，那就取决于主内存的带宽了。 结论：要避免mem-bound，数据量尽量足够小，如果能装的进缓存就高效了。缓存的读取机制 通俗点来讲，当CPU想要读取一个地址的时候,就会跟缓存说，我要读取这个地址，缓存就去查找，看看这个地址有没有存储过，要是存储过就直接将缓存里存的数据返回给CPU，要是没找到，就像下一级缓存下令，让它去读，如果三级缓存也读不到，三级缓存就会向主内存发送请求，就会创建一个新条目，这样下一次再寻找这个数据的时候就不用再去主内存里读取了。 在X86架构中，这个条目的大小是64字节。比如当访问 0x0048~0x0050 这 4 个字节时，实际会导致 0x0040~0x0080 的 64 字节数据整个被读取到缓存中。这64字节叫缓存行，一个读取单位。(数据结构对齐到缓存行) 缓存的数据结构: struct CacheEntry { bool valid; uint64_t address; char data[64]; }; CacheEntry cache[512]; 缓存的写入机制 当CPU写入一个数组时，缓存会查找与该地址匹配的条目，如果找到，那就修改数据，如果没有找到，就创建一个新条目，并且标记为dirty。 当读和写创建的新条目过多，缓存快要塞不下时，他会把最不常用的那个条目移除，这个现象称为失效（invalid）。如果那个条目时刚刚读的时候创建的，那没问题可以删，但是如果那个条目是被标记为脏的，则说明是当时打算写入的数据，那就麻烦了，需要向主内存发送写入请求，等他写入成功，才能安全移除这个条目。 如有多级缓存，则一级缓存失效后会丢给二级缓存。二级再丢给三级，三级最后丢给主内存。 如果访问数组时，按一定的间距跨步访问，则效率如何？ 从1到16都是一样快的，32开始才按2的倍率变快，为什么？ 因为CPU和内存之间隔着缓存，而缓存和内存之间传输数据的最小单位是缓存行（64字节）。16个float是64字节，所以小于64字节的跨步访问，都会导致数据全部被读取出来。而超过64字节的跨步，则中间的缓存行没有被读取，从而变快了。 AOS与SOA和AOSOAstruct a{ int x; int y; int z;};a array[1024]; // AOSstruct a{ int x[1024]; int y[1024]; int z[1024];};a array; // SOAstruct mayclass{ int x[1024]; int y[1024]; int z[1024];}std::vector&amp;lt;myclass&amp;gt; mc(n/1024);// AOSOA, 要保证mc.size()是1024整数倍。 如果只是访问其中一个属性，那么SOA优于AOS，可以保证缓存行的不浪费 如果都要访问，那么AOS优于SOA，这是因为缓存预取机制维护维护的长度是一样的，赛道越多，每个赛道长度越短，prefetch机制优势无法显现(cpu能够预测下一步骤的长度短，假设数组是连续的，一个赛道能提前预测16个，4个赛道能提前预测4个，延迟隐藏不明显)，这个长度就是缓存容量。" }, { "title": "Camera Driver", "url": "/posts/RM/", "categories": "RM", "tags": "", "date": "2023-05-24 05:37:00 +0800", "snippet": "期间相机驱动代码阅读心得体会关于std::function和函数指针异同函数指针和std::function都具有表示函数或者可调用对象，并将他们作为参数传递调用或者使用语法 函数指针是指向函数的指针，通常使用函数指针类型声明，例如 int (*funcPtr)(int, int) 表示一个接受两个整数参数并返回整数的函数指针。 std::function 是C++标准库提供的函数包装器，它可以包装各种可调用对象，包括函数指针、成员函数指针、lambda函数、仿函数等。它的语法更加通用，不需要显式指定参数和返回类型。 举例说明： #include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;// 定义两个不同的函数int add(int a, int b) { return a + b;}int subtract(int a, int b) { return a - b;}int main() { // 创建一个 std::function 对象，可以接受 int(int, int) 类型的可调用对象 std::function&amp;lt;int(int, int)&amp;gt; operation; // 动态选择要调用的函数 bool useAddition = true; // 在运行时决定使用加法还是减法 if (useAddition) { operation = add; } else { operation = subtract; } // 调用所选的函数 int result = operation(5, 3); std::cout &amp;lt;&amp;lt; &quot;Result: &quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl; return 0;} 在这个示例中，我们首先定义了两个不同的函数 add 和 subtract，它们都接受两个整数参数并返回整数。然后，我们创建了一个 std::function 对象 operation，它可以接受类型为 int(int, int) 的可调用对象。通过设置 useAddition 变量，我们在运行时决定使用加法还是减法。根据 useAddition 的值，我们将 operation 对象分配给 add 函数或 subtract 函数。最后，我们调用 operation，并根据选择的函数执行加法或减法操作，获得不同的结果。这个示例展示了如何在运行时根据需要选择不同的可调用对象，以实现动态性。这对于需要根据情境选择不同实现的场景非常有用。可以动态指定。if那里面可以通过。 #include &amp;lt;iostream&amp;gt;// 定义两个函数，它们具有相同的签名int add(int a, int b) { return a + b;}int subtract(int a, int b) { return a - b;}int main() { // 声明一个函数指针，具有与 add 函数相同的签名 int (*operation)(int, int); // 将函数指针指向 add 函数 operation = add; // 使用函数指针调用 add 函数 int result1 = operation(5, 3); std::cout &amp;lt;&amp;lt; &quot;Addition Result: &quot; &amp;lt;&amp;lt; result1 &amp;lt;&amp;lt; std::endl; // 将函数指针指向 subtract 函数 operation = subtract; // 使用函数指针调用 subtract 函数 int result2 = operation(5, 3); std::cout &amp;lt;&amp;lt; &quot;Subtraction Result: &quot; &amp;lt;&amp;lt; result2 &amp;lt;&amp;lt; std::endl; return 0;} 在这个示例中，我们首先定义了两个函数 add 和 subtract，它们都接受两个整数参数并返回整数。然后，我们声明了一个函数指针 operation，它具有与 add 函数相同的签名 int(int, int)。通过将 operation 指向不同的函数，我们可以在运行时选择要调用的函数。首先，我们将 operation 指向 add 函数，然后使用函数指针调用 add 函数来执行加法操作。然后，我们将 operation 指向 subtract 函数，再次使用函数指针来执行减法操作。这个示例展示了如何使用函数指针来在运行时选择不同的函数，以实现动态的函数调用。函数指针对于实现类似于插件系统和函数回调的功能非常有用。不可动态指定。if那里面不可以通过。 类型安全 std::function 提供了类型擦除，使得在运行时可以安全地存储和调用各种可调用对象，而无需显式指定其类型。 函数指针在类型上不够安全，因为它们要求显式指定函数的签名，如果类型不匹配，可能导致运行时错误。 举例说明： // std::function #include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;void printHello() { std::cout &amp;lt;&amp;lt; &quot;Hello, World!&quot; &amp;lt;&amp;lt; std::endl;}int main() { std::function&amp;lt;void()&amp;gt; func; // 声明一个 std::function，表示不带参数且无返回值的函数 func = printHello; // 使用 std::function 存储一个函数指针 func(); // 调用存储在 std::function 中的函数指针 return 0;} 这段表明，在这个示例中，我们使用 std::function 来存储一个指向 printHello 函数的函数指针。由于 std::function 具有类型擦除的能力，它能够安全地存储不同函数签名的可调用对象，而不需要显式指定类型。这使得代码更加灵活，同时也能够在编译时捕获类型不匹配的错误。 // 函数指针#include &amp;lt;iostream&amp;gt;void printHello() { std::cout &amp;lt;&amp;lt; &quot;Hello, World!&quot; &amp;lt;&amp;lt; std::endl;}void printNumber(int num) { std::cout &amp;lt;&amp;lt; &quot;Number: &quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl;}int main() { void (*funcPtr)(); // 声明一个函数指针，表示不带参数且无返回值的函数 funcPtr = printHello; // 存储一个函数指针，匹配函数签名 funcPtr(); // 调用存储在函数指针中的函数 funcPtr = printNumber; // 存储一个不匹配函数签名的函数指针 funcPtr(); // 这里将导致运行时错误，因为函数指针不匹配 return 0;} 在这个示例中，我们使用函数指针来存储函数的地址。在第一次存储时，函数指针与 printHello 函数签名匹配，因此可以成功调用。然而，在第二次存储时，我们将一个不匹配函数签名的函数指针分配给 funcPtr，这样会导致在运行时才发现错误，而不是在编译时。 性能： 函数指针通常比 std::function 更轻量，因为它们没有类型擦除和动态分发的开销。 std::function 由于提供更多的功能和类型安全，可能会有一些性能开销。线程安全 原子性（Atomicity）：原子操作是不可分割的操作，它们要么全部执行成功，要么全部执行失败，不会被其他线程中断。线程安全的代码通常使用原子操作来保护共享资源，以防止多个线程同时修改它们。 互斥访问（Mutual Exclusion）：线程安全的代码使用互斥机制（例如互斥锁或信号量）来确保一次只有一个线程可以访问共享资源。这防止了多个线程同时写入共享资源，从而避免了数据竞争。 同步（Synchronization）：线程安全的代码使用同步机制来协调多个线程的执行顺序，以确保正确的执行顺序。这可以通过条件变量、屏障等实现。 可见性（Visibility）：线程安全的代码要确保一个线程对共享资源的修改对其他线程是可见的。这通常涉及到内存屏障、缓存同步等机制。Camera_Driver 问题一: void triggerAndReceiveBySerialCallback(const std::shared_ptr&amp;lt;TriggerAndReceiveBySerial::Request&amp;gt; request, // NOLINT std::shared_ptr&amp;lt;TriggerAndReceiveBySerial::Response&amp;gt; response); 这个函数中的img_从哪里被赋值? 里面的原子操作应该学习一下。 问题解决，img_来源于 void receiveCallback(cv::Mat &amp;amp;img); 这个函数在CameraDriverNode()构造函数中，在CameraSystem::registerImageCallback里被调用，严格上来说只是把std::function(代表receiveCallback)传进去，真正用的时候在一个回调函数 captureCallback 中， 这个回调函数被用在DaHeng中的初始化中 emStatus = GXRegisterCaptureCallback(m_hDevice, NULL, OnFrameCallbackFun); //发送开采命令 emStatus = GXSendCommand(m_hDevice, GX_COMMAND_ACQUISITION_START); 上面代码中第一步先进行，第二行代码发送指令控制第一个执行。 关于GXSendCommand解释 最好看SDK文档 信号量： img_cv_.notify_one(); // 唤醒一个条件变量 bool ret = img_cv_.wait_for(lock, timeout_, [&amp;amp;]() -&amp;gt; bool { return img_update_; }); // 收到唤醒之后，判断是不是为true，如果是进行下一步，往后执行 流程 先根据配置文件配置相机： // 根据配置文件路径创建相机实例 // 内部会进行枚举，不具备线程安全 void createCameraByProfileCallback(const std::shared_ptr&amp;lt;CreateCameraByProfile::Request&amp;gt; request, // NOLINT std::shared_ptr&amp;lt;CreateCameraByProfile::Response&amp;gt; response) // NOLINT { RCLCPP_INFO(rclcpp::get_logger(&quot;syt_camera_driver_node&quot;), &quot;Incoming create camera by profile request:\\n &quot; &quot;profile path: %s&quot;, request-&amp;gt;profile_path.c_str()); // enum CameraSystem::enumAllCameras(); // create std::string serial_number = CameraSystem::createCameraByProfile(request-&amp;gt;profile_path); if (serial_number != CAMERA_ERROR) { response-&amp;gt;serial_number = serial_number; response-&amp;gt;success = true; } else { RCLCPP_INFO(rclcpp::get_logger(&quot;syt_camera_driver_node&quot;), &quot;Create camera by profile failed:\\n&quot;); response-&amp;gt;success = false; } } CameraSystem::enumAllCameras(); // 把所有存在的相机都枚举出来，包括USB和DaHeng " }, { "title": "first blog", "url": "/posts/first-blog/", "categories": "Tutorial", "tags": "", "date": "2022-10-16 11:48:00 +0800", "snippet": "自己写博客的目的其实就是为了记录一些自己学过的知识，一直想搭一个自己的博客，但是自己水平在那，一直搭不起来，无意间看见上海交通大学前视觉组组长有一篇关于github.io搭建的教程，然后就用他的模板搭了一个。 包括但不仅限于RM，其他的东西也会记录。未来也一定要建立一个自己的博客网站，总不能寄人篱下吧。" } ]
