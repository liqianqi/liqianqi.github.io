<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://liqianqi.github.io/</id><title>liqianqi's blogs</title><subtitle>I hope it will become a grain of gold someday.</subtitle> <updated>2025-04-28T13:46:41+08:00</updated> <author> <name>liqianqi</name> <uri>https://liqianqi.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://liqianqi.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh" href="https://liqianqi.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 liqianqi </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>pt转onnx代码</title><link href="https://liqianqi.github.io/posts/pt2onnx/" rel="alternate" type="text/html" title="pt转onnx代码" /><published>2025-04-28T13:42:00+08:00</published> <updated>2025-04-28T13:42:00+08:00</updated> <id>https://liqianqi.github.io/posts/pt2onnx/</id> <content src="https://liqianqi.github.io/posts/pt2onnx/" /> <author> <name>liqianqi</name> </author> <category term="RM" /> <summary> 转换 目前手头上有一些模型，我经常不知道他们的输入尺寸，但是我知道他们具体的输出格式, [batch_size, dynamic_input], batch_size 通常是 1, 所以代码如下: import torch import os # ==== 配置部分 ==== pt_path = 'C:/Users/20416/Desktop/unitree_rl_gym/motion.pt' # 你的pt路径 onnx_path = 'C:/Users/20416/Desktop/unitree_rl_gym/motion.onnx' # 输出onnx路径 min_dim = 1 max_dim = 512 opset = 11 # 可以改成13或更高（按需） # ==== 加载 TorchScript 模型 ==== print(f"🔵 正在加载TorchSc... </summary> </entry> <entry><title>性能优化</title><link href="https://liqianqi.github.io/posts/prefetch/" rel="alternate" type="text/html" title="性能优化" /><published>2023-12-31T20:40:00+08:00</published> <updated>2025-04-27T11:15:14+08:00</updated> <id>https://liqianqi.github.io/posts/prefetch/</id> <content src="https://liqianqi.github.io/posts/prefetch/" /> <author> <name>liqianqi</name> </author> <category term="RM" /> <summary> 性能优化 cpu-bound 与 内存-bound 通常来说，并行加速只能加速计算部分，不能加速内存读写部分，因此并行计算经常遇到内存瓶颈。 因为一次浮点加法的计算量和访存的超高延迟相比实在太少了。 经验公式: 1次浮点读写 ≈ 8次浮点加法 如果矢量化成功（SSE）：1次浮点读写 ≈ 32次浮点加法 如果CPU有4核且矢量化成功：1次浮点读写 ≈ 128次浮点加法 所以就要足够的计算量来隐藏操作的延迟。 超线程技术: 不一定是两个线程在两个核上同时运行，而是有可能两个线程同时运行在一个核上，由硬件自动来调度。这个主要是针对如果内存卡住，cpu会自动切换到另一个核上。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;... </summary> </entry> <entry><title>Camera Driver</title><link href="https://liqianqi.github.io/posts/RM/" rel="alternate" type="text/html" title="Camera Driver" /><published>2023-05-24T05:37:00+08:00</published> <updated>2023-12-22T17:18:31+08:00</updated> <id>https://liqianqi.github.io/posts/RM/</id> <content src="https://liqianqi.github.io/posts/RM/" /> <author> <name>liqianqi</name> </author> <category term="RM" /> <summary> 期间相机驱动代码阅读心得体会 关于std::function和函数指针异同 函数指针和std::function都具有表示函数或者可调用对象，并将他们作为参数传递调用或者使用 语法 函数指针是指向函数的指针，通常使用函数指针类型声明，例如 int (*funcPtr)(int, int) 表示一个接受两个整数参数并返回整数的函数指针。 std::function 是C++标准库提供的函数包装器，它可以包装各种可调用对象，包括函数指针、成员函数指针、lambda函数、仿函数等。它的语法更加通用，不需要显式指定参数和返回类型。 举例说明： #include &amp;lt;iostream&amp;gt; #include &amp;lt;functional&amp;gt; // 定义两个不同的函数 int add(int a, int b) { return a + b; } ... </summary> </entry> <entry><title>first blog</title><link href="https://liqianqi.github.io/posts/first-blog/" rel="alternate" type="text/html" title="first blog" /><published>2022-10-16T11:48:00+08:00</published> <updated>2022-10-16T11:48:00+08:00</updated> <id>https://liqianqi.github.io/posts/first-blog/</id> <content src="https://liqianqi.github.io/posts/first-blog/" /> <author> <name>liqianqi</name> </author> <category term="Tutorial" /> <summary> 自己写博客的目的 其实就是为了记录一些自己学过的知识，一直想搭一个自己的博客，但是自己水平在那，一直搭不起来，无意间看见上海交通大学前视觉组组长有一篇关于github.io搭建的教程，然后就用他的模板搭了一个。 包括但不仅限于RM，其他的东西也会记录。未来也一定要建立一个自己的博客网站，总不能寄人篱下吧。 </summary> </entry> </feed>
